# Вопрос 5. Линейный поиск. Метод двух указателей. Отрезок с заданной суммой.
# Задача. Необходимо найти непрерывный отрезок массива a0, a1, ... an−1, сумма элементов на котором
# равна k. Элементы массива неотрицательны.

def find_segment_with_sum(arr, k):
    left, right, current_sum = 0, 0, 0
    while right < len(arr):
        current_sum += arr[right]
        while current_sum > k:
            current_sum -= arr[left]
            left += 1
        if current_sum == k:
            return arr[left:right+1]
        right += 1
    return None
  
#   Для решения данной задачи можно использовать метод двух указателей. Этот метод заключается в том, что мы будем двигаться по массиву с помощью двух указателей – левого и правого. Мы будем поддерживать текущую сумму элементов между этими указателями и сдвигать указатели таким образом, чтобы эта сумма была равна заданной сумме k.
#   В этом коде мы инициализируем левый и правый указатели на начало массива и текущую сумму на 0. Затем мы будем двигать правый указатель, пока не достигнем конца массива. На каждойитерации мы будем увеличивать текущую сумму элементов на правом указателе и сдвигать левый указатель вправо, пока сумма не станет меньше или равной k. Если находим отрезок с суммой k, то возвращаем его. Если такого отрезка нет, то возвращаем None.

# Например, если у нас есть массив [1, 4, 20, 3, 10, 5] и мы ищем отрезок с суммой 33, то функция вернет [20, 3, 10].

# !!!Важно отметить, что данный метод работает только для массивов с неотрицательными элементами. Если у вас есть отрицательные элементы, то нужно использовать другой алгоритм, например, алгоритм Кадана.
# Если в массиве могут быть отрицательные числа, то для решения данной задачи можно использовать алгоритм Кадана.

# Алгоритм Кадана заключается в следующем: мы будем идти по массиву и на каждом шаге будем подсчитывать локальную сумму элементов на текущем отрезке. Если эта сумма становится отрицательной, то мы сбрасываем ее в 0 и продолжаем идти дальше. Если же сумма становится больше максимальной суммы, которую мы встретили до этого, то обновляем максимальную сумму.
  
def find_segment_with_sum(arr, k):
    max_sum, current_sum = float('-inf'), 0
    start, end = 0, 0
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum == k:
            return arr[start:i+1]
        if current_sum > max_sum:
            max_sum = current_sum
            end= i
        while current_sum > k and start <= i:
            current_sum -= arr[start]
            start += 1
        if current_sum == k:
            return arr[start:i+1]
    return None

# В этом коде мы инициализируем максимальную сумму и текущую сумму на отрицательную бесконечность и 0 соответственно. Затем мы будем идти по массиву и на каждом шаге будем обновлять текущую сумму и максимальную сумму. Если текущая сумма становится отрицательной, то мы сбрасываем ее в 0 и продолжаем идти дальше. Если же текущая сумма становится больше максимальной суммы, то обновляем максимальную сумму и индексы начала и конца отрезка с максимальной суммой. Если текущая сумма становится больше заданной суммы k, то мы сдвигаем индекс начала отрезка вправо, пока сумма не станет меньше или равной k. Если находим отрезок с суммой k, то возвращаем его. Если такого отрезка нет, то возвращаем None.

# Например, если у нас есть массив [-1, 5, -2, 3, 1, 2, -6, 4] и мы ищем отрезок с суммой 6, то функция вернет [5, -2, 3].

# Таким образом, алгоритм Кадана позволяет решить данную задачу за линейное время O(n), где n - длина массива.
  
  
