# Вопрос 7. Линейные структуры данных. Стек. Определение и реализация. Стек с поддержкой
# минимального элемента.
# Задача «Шарики». В одной компьютерной игре игрок выставляет в линию шарики разных цветов.
# Когда образуется непрерывная цепочка из трех и более шариков одного цвета, она удаляется из
# линии. Все шарики при этом сдвигаются друг к другу, и ситуация может повториться.
# Напишите программу, которая по данной ситуации определяет, сколько шариков будет
# "уничтожено". Естественно, непрерывных цепочек из трех и более одноцветных шаров в
# начальный момент может быть не более одной.
# Входные данные
# Сначала вводится количество шариков в цепочке (не более 1000) и цвета шариков (от 0 до 9,
# каждому цвету соответствует свое целое число).
# Выходные данные
# Требуется вывести количество шариков, которое будет "уничтожено".

# Линейные структуры данных - это структуры данных, которые хранят элементы в линейном порядке, то есть в виде последовательности.

# Стек - это линейная структура данных, которая работает по принципу "последний вошел, первый вышел" (Last-In, First-Out, LIFO). Он представляет собой набор элементов, которые могут быть добавлены и удалены только с одного конца - верхнего.

# В стеке есть две основные операции: добавление элемента в стек (push) и удаление элемента из стека (pop). При добавлении элемента он помещается на вершину стека, а при удалении - удаляется верхний элемент, т.е. последний добавленный.

# В Python стек может быть реализован как список, используя методы append() и pop(). Вот пример создания стека в Python:
# stylus

my_stack = []

# добавление элементов в стек
my_stack.append(1)
my_stack.append(2)
my_stack.append(3)

# удаление элементов из стека
print(my_stack.pop()) # 3
print(my_stack.pop()) # 2
print(my_stack.pop()) # 1

# Стек с поддержкой минимального элемента - это стек, который позволяет получать минимальный элемент в стеке за O(1) времени. Это достигается путем хранения не только элементов стека, но и минимальных значений, которые были добавлены на данный момент.

# Для реализации стека с поддержкой минимального элемента в Python можно использовать стек и дополнительную переменную, которая будет хранить текущий минимальный элемент. При каждом добавлении элемента в стек сравнивается значение этого элемента с текущим минимальным значением. Если добавляемый элемент меньше или равен текущему минимальному значению, то текущее минимальное значение обновляется.

# Вот пример реализации стека с поддержкой минимального элемента в Python:

class MinStack:
    def __init__(self):
        self.stack = []
        self.min_value = float('inf')

    def push(self, x):
        if x <= self.min_value:
            self.stack.append(self.min_value)
            self.min_value = x
        self.stack.append(x)

    def pop(self):
        popped_value = self.stack.pop()
        if popped_value == self.min_value:
            self.min_value = self.stack.pop()

    def top(self):
        return self.stack[-1]

    def get_min(self):
        return self.min_value

# В этом примере мы создали класс MinStack, который имеет функции push, pop, top и get_min. Функция push добавляет элемент в стек и обновляет минимальное значение, если добавляемый элемент меньше или равен текущему минимальному значению. Функция pop удаляет верхний элемент из стека и обновляет минимальное значение, если удаленный элемент был равен текущему минимальному значению. Функция top возвращает верхний элемент стека, а функция get_min возвращает минимальный элемент стека.


# Для решения этой задачи можно использовать стек, чтобы хранить текущую последовательность шариков одного цвета. Мы будем проходить по всем шарикам и добавлять их в стек. Если текущий шарик отличается от предыдущего, то мы проверяем, сколько шариков одного цвета находится в стеке. Если их больше или равно трех, то мы удаляем их и увеличиваем счетчик уничтоженных шариков на их количество. После этого мы очищаем стек и добавляем текущий шарик.

def count_destroyed_balls(n, balls):
    stack = []
    destroyed = 0
    for ball in balls:
        if not stack or stack[-1] == ball:
            stack.append(ball)
        else:
            if len(stack) >= 3:
                destroyed += len(stack)
                stack.clear()
            stack.append(ball)
    if len(stack) >= 3:
        destroyed += len(stack)
    return destroyed

n = int(input())
balls = list(map(int, input().split()))
destroyed_balls = count_destroyed_balls(n, balls))
print(destroyed_balls)

# В этом примере мы сначала считываем количество шариков и их цвета из входных данных, затем вызываем функцию count_destroyed_balls, которая принимает количество шариков и список их цветов. В функции мы создаем пустой стек и счетчик уничтоженных шариков. Затем мы проходим по всем шарикам и добавляем их в стек, если они имеют тот же цвет, что и последний шарик в стеке. Если цвет шарика отличается, то мы проверяем, сколько шариков одного цвета находится в стеке. Если их больше или равно трех, то мы удаляем их из стека, увеличиваем счетчик уничтоженных шариков на их количество и очищаем стек. После этого мы добавляем текущий шарик в стек. Наконец, если после прохода по всем шарикам в стеке остались шарики одного цвета, мы также проверяемих количество и, если их больше или равно трех, увеличиваем счетчик уничтоженных шариков. В конце функция возвращает количество уничтоженных шариков.

# Надеюсь, это помогло вам понять, как решить задачу про шарики в Python! Если у вас есть какие-либо вопросы, не стесняйтесь задавать их мне.
